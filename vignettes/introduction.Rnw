\documentclass{article}

\usepackage{natbib}
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=cyan
}

\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\cov}{cov}

%\VignetteIndexEntry{TrackingParticles - An introduction}
%\VignetteEngine{utils::Sweave}

\begin{document}

\title{TrackingParticles}
\author{Luis Damiano}
\maketitle

\section{Learning outcomes}

\begin{description}
  \item [Statistics] non-linear state-space models, learning more about Particle Filter in the hands-on way.
  \item [Computing] GSL (vector, matrix, rng, ran, linalg), numerical errors handling (see filter.c:118), macros for allowing the code to be compiled standalone, linking C to R, Makevars, creating an R Package, writing a vignette with Sweave, good coding practices (documentation, commenting, version control).
\end{description}

\section{Introduction}

We introduce the bearing-only tracking problem for a moving vehicle. For this R package, which comes with a real-life dataset, we impement in C a Particle Filter to estimate the position and velocity of a moving object tracked by passive sensors based on a non-linear state-space model with known parameters.

In Summer 2014, a tractor harvested an experimental agricultural site codenamed Interim, which is located at the Neal Smith National Wildlife Refuge. The vehicle was equipped with a yield monitor, a common device for precision agriculture that records several quantities of interests generated by sensors in real time. We assume the existence of two passive sensors situated at the coordinates $41^\circ33'22.9"$N $93^\circ14'58.1"$W and $41^\circ33'27.6"$N $93^\circ14'51.1"W$ tracking solely this target. Every second, each sensor would record the horizontal angle in radians in the direction of the moving target and itself. The dataset contains a total of 11027 pairs of observations.

It is of interest to estimate the position of the moving target at each time step. A noiseless approximation could be produced by fixing the velocity equal to zero and estimating the position from the crossing of the measurements. By finding the solution to the following linear system,

\begin{equation}
  \begin{pmatrix}
  \cos a_1 & \cos a_2 \\
  \sin a_1 & \sin a_2
  \end{pmatrix}
  \begin{pmatrix}
  d_1 \\
  d_2
  \end{pmatrix}
  =
  \begin{pmatrix}
  s_{x}^{2} - s_{x}^{1} \\
  s_{y}^{2} - s_{y}^{1}
  \end{pmatrix},
\end{equation}

the position could be recovered as

\begin{equation}
  \begin{pmatrix}
  \hat{x}_k \\
  \hat{y}_k
  \end{pmatrix}
  =
  d1
  \begin{pmatrix}
  \cos a_1 \\
  \sin a_1
  \end{pmatrix}.
\end{equation}

As we live in a world full of uncertainty (or is it just me?), we employ instead a non-linear state-space model as described in S\"{a}rkk\"{a} (2013). The measurement model for the $i$-th sensor with $i \in \{1, 2\}$ is given by

\begin{equation}
a_{k}^{i}=\tan ^{-1}\left(\frac{y_{k}-s_{y}^{i}}{x_{k}-s_{x}^{i}}\right)+r_{k},
\end{equation}

where $\left(s_{x}^{i}, s_{y}^{i}\right)$ is the position of the sensor and $r_k \sim N(0, \sigma^2)$ is a Gaussian measurement noise with standard deviation $\sigma > 0$ measured in radians.

The state of the vehicle at time step $k$ could be represented by the latent vector $\mathbf{x}_k = (x_k, y_k, \dot{x}_k, \dot{y}_k)^T$, where the elements are the the position and velocity respectively. The state dynamics could be then modeled with the discretized Wiener velocity model as follows:

\begin{equation}
  \left( \begin{array}{l}{x_{k}} \\ {y_{k}} \\ {\dot{x}_{k}} \\ {\dot{y}_{k}}\end{array} \right) = \left( \begin{array}{cccc}{1} & {0} & {\Delta t} & {0} \\ {0} & {1} & {0} & {\Delta t} \\ {0} & {0} & {1} & {0} \\ {0} & {0} & {0} & {1}\end{array}\right) \left( \begin{array}{l}{x_{k-1}} \\ {y_{k-1}} \\ {\dot{x}_{k-1}} \\ {\dot{y}_{k-1}}\end{array}\right)+\mathbf{q}_{k-1}.
\end{equation}

The variable $\mathbf{q}_{k-1}$ is a zero-mean Gaussian process noise with covariance

\begin{equation}
\mathbf{Q} =
  \left(
    \begin{array}{cccc}{
      q_{1}^{\mathrm{c}} \Delta t^{3} / 3} & {0} & {q_{1}^{\mathrm{c}} \Delta t^{2} / 2} & {0} \\
      {0} & {q_{2}^{\mathrm{c}} \Delta t^{3} / 3} & {0} & {q_{2}^{\mathrm{c}} \Delta t^{2} / 2} \\
      {q_{1}^{\mathrm{c}} \Delta t^{2} / 2} & {0} & {q_{1}^{\mathrm{c}} \Delta t} & {0} \\
      {0} & {q_{2}^{\mathrm{c}} \Delta t^{2} / 2} & {0} & {q_{2}^{\mathrm{c}} \Delta t}
    \end{array}\right),
\end{equation}

where the constant $\Delta t \ge 0$ represents the sampling period measured as times per seconds (e.g. $\Delta t = 0.1$ means ten times per second), and the constants $q_1^c > 0$ and $q_2^c > 0$ are the diffusion coefficients.

\section{Filtering}

Linear state-space models with Gaussian noise have the popular closed-form solution known as Kalman Filter. In this particular case, we propose a Particle Filter (with a caveat) to estimate the posterior mean of the latent state at each time step given a fixed value for the model parameter vector.

The Sequential Importance Resampling (SIR algorithm), also known as the Particle Filter (PF), is the following.

\noindent\hfil\rule{0.7\textwidth}{.4pt}\hfil

\textbf{Step 0}. Draw $N$ samples $\mathbf{x}_{0}^{(i)}$ of the latent state vector from the prior distribution:

\begin{equation}
\mathbf{x}_{0}^{(i)} \sim p\left(\mathbf{x}_{0}\right), \quad i=1, \ldots, N,
\end{equation}

and set all weights to the constant $w_{0}^{(i)} = N^{-1} \ \forall \ i$.

\noindent\hfil\rule{0.7\textwidth}{.4pt}\hfil

For each time step $k = 1, \dots, T$, do the following.

\textbf{Step 1}. Draw $N$ samples $\mathbf{x}_{k}^{(i)}$ from the importance distribution:

\begin{equation}
\mathbf{x}_{k}^{(i)} \sim \pi\left(\mathbf{x}_{k} | \mathbf{x}_{k-1}^{(i)}, \mathbf{y}_{1 : k}\right), \quad i=1, \ldots, N.
\end{equation}

\textbf{Step 2}. Compute the new weights:

\begin{equation}
w_{k}^{(i)} \propto w_{k-1}^{(i)} \frac{p\left(\mathbf{y}_{k} | \mathbf{x}_{k}^{(i)}\right) p\left(\mathbf{x}_{k}^{(i)} | \mathbf{x}_{k-1}^{(i)}\right)}{\pi\left(\mathbf{x}_{k}^{(i)} | \mathbf{x}_{k-1}^{(i)}, \mathbf{y}_{1 : k}\right)}.
\end{equation}

\textbf{Step 3}. Normalize the weights to sum to unity:

\begin{equation}
\bar{w}_{k}^{(i)} = \frac{w_{k}^{(i)}}{\sum_{i = 1}^{N}{w_{k}^{(i)}}}.
\end{equation}

\textbf{Step 4}. Compute the effective number of particles:

\begin{equation}
n_{\mathrm{eff}} \approx \frac{1}{\sum_{i=1}^{N}\left(\bar{w}_{k}^{(i)}\right)^{2}}.
\end{equation}

\textbf{Step 5}. If the effective number of particles is too low for a given decision rule, resample with repetition the particles $\mathbf{x}_{k}^{(i)}$ with probability $\bar{w}_{k}^{(i)}$ and set all weights to the constant $w_{k}^{(i)} = N^{-1} \ \forall \ i$.

\noindent\hfil\rule{0.7\textwidth}{.4pt}\hfil

Caveat: the resampling step is not currently implemented -- expect particle degeneracy.

\section{Instructions}

We present a minimal example illustrating how to (1) set up all the known parameters, (2) run the particle filter, and (3) plot the results. The object returned by the \texttt{particle\_filter} function is a named list with four elements:

\begin{description}
  \item [noiseless] is a T x 2 matrix with the noiseless approximation of the vehicle position (assumes no noise and velocity equal to zero).
  \item [stateMean] is a T x 4 matrix with the posterior mean of the latent state at each time step.
  \item [weights] is a T x nParticles matrix with the normalized weights.
  \item [ess] is a T-sized vector with the effective sample size at each time step.
\end{description}

For more information, we encourage the reader to read the package manual: from R, simply run \texttt{help(package=TrackingParticles)}, or call \texttt{?particle\_filter}, \texttt{?vehicle}, and \texttt{?plot.filtered}.

\scriptsize

<<example, echo=TRUE, fig.height = 4>>=
library(TrackingParticles)

head(vehicle)

# Set up model constants and known values ---------------------------------
nParticles <- 100

# Time step in seconds
dt <- 1

# Location of sensors 1 and 2
s1 <- c(x = -93.2494663765932, y = 41.5563518606521)
s2 <- c(x = -93.2475338232000, y = 41.5576632356000)

# Measurement model parameters
sr <- 0.01

# State model parameters
q1 <- 0.0005
q2 <- 0.0005

# State model priors
statepriorMu   <- c(-93.24952047, 41.55575337)
statepriorDiag <- c(5.0E-09, 3.5E-08, 5.0E-04, 5.0E-04)

# Importance distribution parameters
# If you ever wonder how I found 0.0025, let's just call it heuristics :D
importanceDiag <- 0.0025 * c(5.00E-10, 1.75E-08, 5.00E-05, 5.00E-05)

# Run ---------------------------------------------------------------------
res <- particle_filter(
  vehicle,
  dt,
  s1, s2,
  sr,
  q1, q2,
  statepriorMu, statepriorDiag,
  importanceDiag,
  nParticles
)

print(str(res))

# Package comes with a basic visualization routine ------------------------
plot(res, pch  = 16, col = "darkgray", cex = 0.3)

# Finally, the functions are fully documented.
help(package = TrackingParticles)
@

\section{References}

\normalsize

Simo S\"{a}rkk\"{a}. 2013. ``Bayesian Filtering and Smoothing''. \emph{Cambridge University Press}. \href{http://users.aalto.fi/~ssarkka/pub/cup_book_online_20131111.pdf}{Read online}.

\end{document}
